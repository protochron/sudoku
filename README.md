# Sudoku Solver

This project implements a sudoku solver that uses recursive backtracking to solve the puzzle.

The algorithm is roughly equivalent to the following:

    For cell at row, col:
      if the value is set at row, col:
        solve_next_position
      For value in 1..9:
        assign value and solve_next_position
        return true if the recursive application was uscessful
        else unset value and return false

This is probably one of the easier methods to solve a sudoku puzzle besides trying to brute force the entire thing (9^num_empty_spaces). Since a brute force approach could potentially take longer than the current age of the universe then we need to be a little smarter in how we solve the problem. Fortunately, recursively backtracking gives us a good compromise by allowing us to perform a depth-first search using valid values and resetting the search to the last known good state before iterating to the next possible value.

Since this is a search problem, there are other interesting approaches such as [simulated annealing](https://xianblog.wordpress.com/2010/02/23/sudoku-via-simulated-annealing/). [Peter Norvig](http://norvig.com/sudoku.html) has a very good overview of how to add some heuristics to cut down the search space even further.

In this particular approach, the best case scenario is if the board is already solved in which case the runtime should only be O(n) in order to validate each cell has a legal value. Typically, the runtime should be O(n ^ m) where n is the number of possibilities (9) and m is the number of empty spaces in the board. However, in practice the runtime should be much better than that since check whether or not a solution for the whole puzzle is valid at each branch we check.

## Implementation
The solution is a single class that contains the board as an array of arrays. The board is used as a shared state by the sudoku solver to cut down on the amount of memory used at the cost of having to be careful about resetting values when they are found to be invalid. I could have added classes to represent a cell but that felt like overkill.

I would have liked to have tried to implement a more novel solution such as using a genetic algorithm if I had more time, but a recursive backtracking approach seemed like the quickest way to solve the problem without being overly complex.


# Requirements
* Docker
* Ruby (tested against 2.2.3 and 2.3.0)
* A C compiler

# Build
The easiest way to run everything is through the Docker container

    docker build -t protochron/sudoku .

# Run the sudoku solver
The sudoku solver accepts a puzzle in CSV form over STDIN

You can run it by simply calling

    ./sudoku/sudoku

If you want to use the docker container then you can run

    cat puzzle.txt | docker run --rm protochron/sudoku

# Run the factoral solutions
There are two implementations of a factoral function: one in C and one in Ruby. The C solution is built in to the docker container (although there is a Makefile you can use to build it locally)

    # C version
    docker run --rm -it protochron/sudoku factoral/factoral 12

    # Ruby version
    docker run --rm -it protochron/sudoku sh -c 'ruby factoral/factoral.rb 12'

# Documentation
Documentation can be generated by running

    bundle exec yardoc

# Testing
The test suite can be run by executing

    rake test

There are a set of performance tests that run through 50 sudoku puzzles in sequence. These can be run by calling

    rake test:slow
